//
// auto-generated by op2.py
//

//user function
//#include "save_soln.h"

std::vector<double> save_soln(const double *q, double *qold){
    std::vector<double> result(4,0);
    
    for (int n=0; n<4; n++) qold[n] = q[n];
    
    result=qold;
    return result;
}

HPX_PLAIN_ACTION(save_soln,save_soln_action);


// host stub function
void op_par_loop_save_soln(char const *name, op_set set,
                           op_arg arg0,
                           op_arg arg1){
    
    int nargs = 2;
    op_arg args[2];
    
    args[0] = arg0;
    args[1] = arg1;
    
    // initialise timers
    double cpu_t1, cpu_t2, wall_t1, wall_t2;
    op_timing_realloc(0);
    op_timers_core(&cpu_t1, &wall_t1);
    
    
    if (OP_diags>2) {
        printf(" kernel routine w/o indirection:  save_soln");
    }
    
    op_mpi_halo_exchanges(set, nargs, args);
    // set number of threads
#ifdef _OPENMP
    int nthreads = omp_get_max_threads();
#else
    int nthreads = 1;
#endif
    
    if (set->size >0) {
        
        // execute plan
//#pragma omp parallel for
        
        // new_data[i][0 ,1, 2] which i is thr
        std::vector<std::vector<hpx::shared_future<double> > > new_data(2);
        
        for ( int thr=0; thr<nthreads; thr++ ){
            
            
            
            int start  = (set->size* thr)/nthreads;
            int finish = (set->size*(thr+1))/nthreads;
            
            new_data[thr].resize(finish-start);
            
            
            
            new_data[blockIdx] = [start, finish, &arg0, &arg1](){
                
                typedef boost::counting_iterator<std::size_t> iterator;
                std::vector<std::vector<hpx::shared_future<double>> new_data(finish-start,
                                                                             std::vector<hpx::shared_future<double>(arg1.data->size));
                
                for_each(par, iterator(start), iterator(finish-1),
                         [&new_data](std::size_t i)
                         {
                             
                             new_data[i] = hpx::async<save_soln_action>(hpx::find_here(),
                                                                        &((double*)arg0.data)[4 * i],
                                                                        &((double*)arg1.data)[4 * i]);
                         }
                         
                         
                         return new_data;
           };
                         
                         

            
            /*for ( int n=start; n<finish; n++ ){
                save_soln(
                          &((double*)arg0.data)[4*n],
                          &((double*)arg1.data)[4*n]);
            }*/
        }
      
        
        
        
    }
    
    hpx::wait_all(new_data);//wait for all blocks, but I think it will not work
    
    // combine reduction data
    op_mpi_set_dirtybit(nargs, args);
    
    // update kernel record
    op_timers_core(&cpu_t2, &wall_t2);
    OP_kernels[0].name      = name;
    OP_kernels[0].count    += 1;
    OP_kernels[0].time     += wall_t2 - wall_t1;
    OP_kernels[0].transfer += (float)set->size * arg0.size;
    OP_kernels[0].transfer += (float)set->size * arg1.size;
}