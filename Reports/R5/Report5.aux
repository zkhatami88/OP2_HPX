\relax 
\providecommand\zref@newlabel[2]{}
\citation{r11,r12}
\citation{r7}
\citation{r14}
\citation{r19}
\citation{r6}
\citation{r7}
\citation{o9,o10,o11}
\citation{o1}
\citation{o2,o12}
\citation{o2,o3}
\citation{o1}
\citation{o2,o3,o4}
\citation{o4}
\providecommand \oddpage@label [2]{}
\select@language{english}
\@writefile{toc}{\select@language{english}}
\@writefile{lof}{\select@language{english}}
\@writefile{lot}{\select@language{english}}
\@writefile{toc}{\contentsline {section}{\numberline {I}Introduction}{}}
\citation{o2,o7}
\citation{o1}
\citation{o3,o4}
\citation{o8}
\citation{o3}
\citation{r6}
\citation{r15}
\citation{r19}
\citation{r20}
\citation{o8}
\@writefile{toc}{\contentsline {section}{\numberline {II}OP2}{}}
\newlabel{sec:op2}{{II}{}}
\@writefile{toc}{\contentsline {section}{\numberline {III}HPX}{}}
\newlabel{sec:hpx}{{III}{}}
\@writefile{toc}{\contentsline {section}{\numberline {IV}Airfoil code with HPX}{}}
\newlabel{sec:air}{{IV}{}}
\citation{o8}
\citation{r23}
\citation{hpx_v0.9.11}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces The principle of operation of a \textit  {$future$} in HPX\relax }}{}}
\providecommand*\caption@xref[2]{\@setref\relax\@undefined{#1}}
\newlabel{f4}{{1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Five loops are used in \texttt  {airfoil.cpp} for saving old data values, applying the computation on each data value and updating them. \texttt  {save\_soln} and \texttt  {update} loops are $direct$ loops and the others are $indirect$ one.}\relax }}{}}
\newlabel{l1}{{2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {\texttt  {\#pragma omp parallel for} is used for loop parallelization in OP2 for Airfoil application to obtain the loop parallelization on one node and also on the distributed nodes using MPI.}\relax }}{}}
\newlabel{l2}{{3}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {IV-A}}\texttt  {hpx::parallel::for\_each} }{}}
\newlabel{sec:for}{{\unhbox \voidb@x \hbox {IV-A}}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Implementing \texttt  {hpx::parallel::for\_each} for loop parallelization in OP2 for Airfoil application. HPX is able to control a grain size in this method. As a result, it helps in reducing processor starvation caused by the fork-join barrier at the end of the execution of the parallel loop.}\relax }}{}}
\newlabel{l3}{{4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Implementing \texttt  {hpx::parallel::for\_each} for loop parallelization in OP2 for Airfoil application. HPX is able to avoid degrading the scalability for small loops with defining a static grain size with \texttt  {hpx::parallel::dynamic\_chunk\_size dcs(SIZE)} before the parallel loop execution.}\relax }}{}}
\newlabel{l3b}{{5}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {IV-B}}\texttt  {hpx::lcos::local::dataflow} with \texttt  {hpx::parallel::for\_each}}{}}
\newlabel{sec:async}{{\unhbox \voidb@x \hbox {IV-B}}{}}
\citation{hpx_v0.9.11}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Implementing \texttt  {hpx::parallel::for\_each} within \texttt  {hpx::lcos::local::dataflow} for loop parallelization in OP2 for Airfoil application. It makes the invocation of the loop asynchronous and return $future$, which is is stored in \texttt  {new\_data}. \texttt  {hpx::lcos::local::dataflow} allows automatically creating the execution graph which represents a dependency tree.}\relax }}{}}
\newlabel{l3b}{{6}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {\texttt  {airfoil.cpp} is changed for using \texttt  {hpx::async} for loop parallelization in OP2. \texttt  {new\_data} is returned from each kernel function after calling \texttt  {op\_par\_loop} and \texttt  {hpx::wait\_all} is used after each loop till completing the results related to the previous loops.}\relax }}{}}
\newlabel{l4}{{7}{}}
\@writefile{toc}{\contentsline {section}{\numberline {V}Experimental Results}{}}
\newlabel{sec:res}{{V}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Execution time of an Airfoil application with \texttt  {\#pragma omp parallel for} and \texttt  {hpx::parallel::for\_each} (dynamic and static \texttt  {chunk\_size}) used for an Airfoil application with up to 64 threads.}\relax }}{}}
\newlabel{f1b}{{8}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Comparison results of strong scaling between \texttt  {\#pragma omp parallel for} and \texttt  {hpx::parallel::for\_each} with dynamic and static \texttt  {chunk\_size} used for an Airfoil application with up to 64 threads. HPX allows controlling a grain size while using \texttt  {hpx::parallel::for\_each} to improve scalability. The results illustrate a better performance for \texttt  {hpx::parallel::for\_each} with the static \texttt  {chunk\_size} compared to the dynamic \texttt  {chunk\_size} for small loops. However, OpenMP performs better than HPX in this example.}\relax }}{}}
\newlabel{f1}{{9}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Execution time of an Airfoil application with \texttt  {\#pragma omp parallel for} and \texttt  {hpx::lcos::local::dataflow} with \texttt  {hpx::parallel::for\_each} used for an Airfoil application with up to 64 threads.}\relax }}{}}
\newlabel{f2b}{{10}{}}
\bibdata{References}
\bibcite{r11}{1}
\bibcite{r12}{2}
\bibcite{r7}{3}
\bibcite{r14}{4}
\bibcite{r19}{5}
\bibcite{r6}{6}
\bibcite{o9}{7}
\bibcite{o10}{8}
\bibcite{o11}{9}
\bibcite{o1}{10}
\bibcite{o2}{11}
\bibcite{o12}{12}
\bibcite{o3}{13}
\bibcite{o4}{14}
\bibcite{o7}{15}
\bibcite{o8}{16}
\bibcite{r15}{17}
\bibcite{r20}{18}
\bibcite{r23}{19}
\bibcite{hpx_v0.9.11}{20}
\bibstyle{IEEEtran}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Comparison results of strong scaling between \texttt  {hpx::lcos::local::dataflow} with \texttt  {hpx::parallel::for\_each} and \texttt  {\#pragma omp parallel for} used for Airfoil application with up to 64 threads. The results illustrate a better performance for \texttt  {hpx::lcos::local::dataflow} for the larger number of threads, which is due to the asynchronous task execution. \texttt  {hpx::lcos::local::dataflow} automatically generated an execution tree, which represents a dependency graph and allows to execute a function asynchronously. }\relax }}{}}
\newlabel{f2}{{11}{}}
\@writefile{toc}{\contentsline {section}{\numberline {VI}Conclusion}{}}
\newlabel{sec:future}{{VI}{}}
\@writefile{toc}{\contentsline {section}{References}{}}
