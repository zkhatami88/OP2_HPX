\relax 
\providecommand\zref@newlabel[2]{}
\citation{r11,r12}
\citation{r7}
\citation{r14}
\citation{r19}
\citation{r6}
\citation{r7}
\citation{o9,o10,o11}
\citation{o1}
\citation{o2,o12}
\citation{o2,o3}
\providecommand \oddpage@label [2]{}
\select@language{english}
\@writefile{toc}{\select@language{english}}
\@writefile{lof}{\select@language{english}}
\@writefile{lot}{\select@language{english}}
\@writefile{toc}{\contentsline {section}{\numberline {I}Introduction}{}}
\citation{o1}
\citation{o2,o3,o4}
\citation{o4}
\citation{o2,o7}
\citation{o1}
\citation{o8}
\citation{o3,o4}
\citation{o3}
\citation{r6}
\@writefile{toc}{\contentsline {section}{\numberline {II}OP2}{}}
\newlabel{sec:op2}{{II}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {\texttt  {op\_par\_loop\_save\_soln} and \texttt  {op\_par\_loop\_adt\_calc} loops from an Airfoil application. \texttt  {op\_par\_loop\_save\_soln} loop is a $direct$ loop and \texttt  {op\_par\_loop\_adt\_calc} is an $indirect$ loop.}\relax }}{}}
\providecommand*\caption@xref[2]{\@setref\relax\@undefined{#1}}
\newlabel{o1}{{1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {III}HPX}{}}
\newlabel{sec:hpx}{{III}{}}
\citation{r15}
\citation{r19}
\citation{r20}
\citation{o8}
\citation{o8}
\citation{r23}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces The principle of operation of a \textit  {$future$} in HPX\relax }}{}}
\newlabel{f4}{{2}{}}
\@writefile{toc}{\contentsline {section}{\numberline {IV}Airfoil application with HPX}{}}
\newlabel{sec:air}{{IV}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Five loops are used in \texttt  {airfoil.cpp} for saving old data values, applying the computation on each data value and updating them. \texttt  {save\_soln} and \texttt  {update} loops are $direct$ loops and the others are $indirect$ one.}\relax }}{}}
\newlabel{l1}{{3}{}}
\citation{p1}
\citation{hpx_v0.9.11}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {\texttt  {\#pragma omp parallel for} is used for loop parallelization in OP2 for Airfoil application to obtain the loop parallelization on one node and also on the distributed nodes using MPI.}\relax }}{}}
\newlabel{l2}{{4}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {IV-A}}\textbf  {HPX without changing OP2 API}}{}}
\newlabel{sec:without}{{\unhbox \voidb@x \hbox {IV-A}}{}}
\newlabel{sec:for}{{\unhbox \voidb@x \hbox {IV-A}1}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {\unhbox \voidb@x \hbox {IV-A}1}\textbf  {\texttt  {parallel::for\_each}}}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Implementing \texttt  {hpx::parallel::for\_each} for loop parallelization in OP2 for Airfoil application. HPX is able to control a grain size in this method. As a result, it helps in reducing processor starvation caused by the fork-join barrier at the end of the execution of the parallel loop.}\relax }}{}}
\newlabel{l3}{{5}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Implementing \texttt  {hpx::parallel::for\_each} for loop parallelization in OP2 for Airfoil application. HPX is able to avoid degrading the scalability for small loops with defining a static grain size with \texttt  {hpx::parallel::dynamic\_chunk\_size scs(SIZE)} before the parallel loop execution.}\relax }}{}}
\newlabel{l3b}{{6}{}}
\citation{r7}
\newlabel{sec:async}{{\unhbox \voidb@x \hbox {IV-A}2}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {\unhbox \voidb@x \hbox {IV-A}2}\textbf  {\texttt  {async} and \texttt  {parallel::for\_each}}}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Implementing \texttt  {hpx::async} and \texttt  {hpx::parallel::for\_each} with \texttt  {hpx::parallel::par} for a $direct$ loop parallelization in OP2 for Airfoil application. The returned $future$ representing the result of a function.}\relax }}{}}
\newlabel{l6}{{7}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Implementing \texttt  {hpx::parallel::for\_each} with \texttt  {hpx::parallel::par(task)} for an $indirect$ loop parallelization in OP2 for Airfoil application. The returned $future$ representing the result of a function.}\relax }}{}}
\newlabel{l6b}{{8}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {IV-B}}\textbf  {HPX with the modified OP2 API}}{}}
\newlabel{sec:with}{{\unhbox \voidb@x \hbox {IV-B}}{}}
\citation{r7}
\citation{r7}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {\texttt  {airfoil.cpp} is changed while using \texttt  {hpx::async} and \texttt  {hpx::parallel::par(task)} for loop parallelization in OP2. \texttt  {new\_data} is returned from each kernel function after calling \texttt  {op\_par\_loop} and \texttt  {new\_data.get()} is used to get $futures$ ready before the next steps.}\relax }}{}}
\newlabel{l4}{{9}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces A Dataflow object encapsulates a function $F(in_1,in_2,...,in_n)$ with $n$ inputs from different data resources. As soon as the last input argument has been received, the function $F$ is scheduled for an execution \cite  {r7}.\relax }}{}}
\newlabel{o3}{{10}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {\texttt  {op\_arg\_dat} is modified to create an argument as a $future$, which is passed to a function through \texttt  {op\_par\_loop}.}\relax }}{}}
\newlabel{o2}{{11}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {12}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Implementing \texttt  {hpx::parallel::for\_each} within \texttt  {hpx::lcos::local::dataflow} for loop parallelization in OP2 for Airfoil application. It makes the invocation of the loop asynchronous and return $future$, which is is stored in \texttt  {new\_data}. \texttt  {hpx::lcos::local::dataflow} allows automatically creating the execution graph which represents a dependency tree.}\relax }}{}}
\newlabel{l6b}{{12}{}}
\citation{hpx_v0.9.11}
\@writefile{lof}{\contentsline {figure}{\numberline {13}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {\texttt  {airfoil.cpp} is changed while using \texttt  {hpx::lcos::local::dataflow} for loop parallelization in OP2. \texttt  {data[t]} is returned from each kernel function after calling \texttt  {op\_par\_loop} using \texttt  {data[t-1]}.}\relax }}{}}
\newlabel{l3c}{{13}{}}
\@writefile{toc}{\contentsline {section}{\numberline {V}Experimental Results}{}}
\newlabel{sec:res}{{V}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {14}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Comparison results of strong scaling between \texttt  {\#pragma omp parallel for} and \texttt  {hpx::parallel::for\_each(par)} with dynamic and static \texttt  {chunk\_size} used for an Airfoil application with up to 64 threads. HPX allows controlling a grain size while using \texttt  {hpx::parallel::for\_each} to improve scalability. The results illustrate a better performance for \texttt  {hpx::parallel::for\_each} with the static \texttt  {chunk\_size} compared to the dynamic \texttt  {chunk\_size} for small loops. }\relax }}{}}
\newlabel{f1}{{14}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {15}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Comparison results of strong scaling between \texttt  {\#pragma omp parallel for} and \texttt  {hpx::async} with \texttt  {hpx::parallel::for\_each(par(task))} used for Airfoil application with up to 64 threads. The results illustrate a better performance for \texttt  {hpx::async}, which is due to the asynchronous task execution provided with a returned $future$. }\relax }}{}}
\newlabel{f3}{{15}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {16}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Comparison results of strong scaling between \texttt  {hpx::lcos::local::dataflow} and \texttt  {\#pragma omp parallel for} used for Airfoil application with up to 64 threads. The results illustrate a better performance for \texttt  {hpx::lcos::local::dataflow} for the larger number of threads, which is due to the asynchronous task execution. \texttt  {hpx::lcos::local::dataflow} automatically generated an execution tree, which represents a dependency graph and allows to execute a function asynchronously. }\relax }}{}}
\newlabel{f2}{{16}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {17}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  {Comparison results of a weak scaling between \texttt  {\#pragma omp parallel for}, \texttt  {hpx::parallel::for\_each}, \texttt  {hpx::async} and \texttt  {hpx::lcos::local::dataflow} used for Airfoil application. The results illustrate a better performance for \texttt  {hpx::lcos::local::dataflow}, which shows the perfect overlap of computation with communication enabled by HPX.}\relax }}{}}
\newlabel{f5}{{17}{}}
\bibdata{References}
\bibcite{r11}{1}
\bibcite{r12}{2}
\bibcite{r7}{3}
\bibcite{r14}{4}
\bibcite{r19}{5}
\bibcite{r6}{6}
\bibcite{o9}{7}
\bibcite{o10}{8}
\bibcite{o11}{9}
\bibcite{o1}{10}
\bibcite{o2}{11}
\bibcite{o12}{12}
\bibcite{o3}{13}
\bibcite{o4}{14}
\bibcite{o7}{15}
\bibcite{o8}{16}
\bibcite{r15}{17}
\bibcite{r20}{18}
\bibcite{r23}{19}
\bibcite{p1}{20}
\@writefile{toc}{\contentsline {section}{\numberline {VI}Conclusion}{}}
\newlabel{sec:future}{{VI}{}}
\@writefile{toc}{\contentsline {section}{References}{}}
\bibcite{hpx_v0.9.11}{21}
\bibstyle{IEEEtran}
